package main

//MockUsecaseTemplate template mock usecase
const MockUsecaseTemplate = `package mock

import (
	"context"
	"{{$.GoModules}}/internal/modules/{{$.module}}/domain"

	"{{$.LibraryAddress}}/golibshared"
	"github.com/stretchr/testify/mock"
)

// {{clean (upper $.module)}}Usecase is an autogenerated mock type for the {{clean (upper $.module)}}Usecase type
type {{clean (upper $.module)}}Usecase struct {
	mock.Mock
}

// FindAll provides a mock function with given fields: ctx, filter
func (_m *{{clean (upper $.module)}}Usecase) FindAll(ctx context.Context, filter *domain.Filter) ([]*domain.{{clean (upper $.module)}}, *golibshared.Meta, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*domain.{{clean (upper $.module)}}
	if rf, ok := ret.Get(0).(func(context.Context, *domain.Filter) []*domain.{{clean (upper $.module)}}); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.{{clean (upper $.module)}})
		}
	}

	var r1 *golibshared.Meta
	if rf, ok := ret.Get(1).(func(context.Context, *domain.Filter) *golibshared.Meta); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*golibshared.Meta)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *domain.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FindByID provides a mock function with given fields: ctx, data
func (_m *{{clean (upper $.module)}}Usecase) FindByID(ctx context.Context, ID string) (*domain.{{clean (upper $.module)}}, error) {
	ret := _m.Called(ctx, ID)

	var r0 *domain.{{clean (upper $.module)}}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.{{clean (upper $.module)}}); ok {
		r0 = rf(ctx, ID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.{{clean (upper $.module)}})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, ID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Create provides a mock function with given fields: ctx, data
func (_m *{{clean (upper $.module)}}Usecase) Create(ctx context.Context, data *domain.{{clean (upper $.module)}}) (*domain.{{clean (upper $.module)}}, error) {
	ret := _m.Called(ctx, data)

	var r0 *domain.{{clean (upper $.module)}}
	if rf, ok := ret.Get(0).(func(context.Context, *domain.{{clean (upper $.module)}}) *domain.{{clean (upper $.module)}}); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.{{clean (upper $.module)}})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *domain.{{clean (upper $.module)}}) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: ctx, data, ID
func (_m *{{clean (upper $.module)}}Usecase) Update(ctx context.Context, data *domain.{{clean (upper $.module)}}, ID string) (*domain.{{clean (upper $.module)}}, error) {
	ret := _m.Called(ctx, data, ID)

	var r0 *domain.{{clean (upper $.module)}}
	if rf, ok := ret.Get(0).(func(context.Context, *domain.{{clean (upper $.module)}}, string) *domain.{{clean (upper $.module)}}); ok {
		r0 = rf(ctx, data, ID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.{{clean (upper $.module)}})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *domain.{{clean (upper $.module)}}, string) error); ok {
		r1 = rf(ctx, data, ID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveByID provides a mock function with given fields: ctx, data, ID
func (_m *{{clean (upper $.module)}}Usecase) RemoveByID(ctx context.Context, ID string) error {
	ret := _m.Called(ctx, ID)

	var r0 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r0 = rf(ctx, ID)
	} else {
		r0 = ret.Error(1)
	}

	return r0
}

// RestoreByID provides a mock function with given fields: ctx, data, ID
func (_m *{{clean (upper $.module)}}Usecase) RestoreByID(ctx context.Context, ID string) error {
	ret := _m.Called(ctx, ID)

	var r0 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r0 = rf(ctx, ID)
	} else {
		r0 = ret.Error(1)
	}

	return r0
}
`

//InterfaceUsecaseTemplate template interface usecase
const InterfaceUsecaseTemplate = `package usecase

import (
	"context"
	"{{$.GoModules}}/internal/modules/{{$.module}}/domain"

	"{{$.LibraryAddress}}/golibshared"
)

// {{clean (upper $.module)}}Usecase abstract interface
type {{clean (upper $.module)}}Usecase interface {
	FindAll(ctx context.Context, filter *domain.Filter) ([]*domain.{{clean (upper $.module)}}, *golibshared.Meta, error)
	FindByID(ctx context.Context, ID string) (*domain.{{clean (upper $.module)}}, error)
	Create(ctx context.Context, data *domain.{{clean (upper $.module)}}) (*domain.{{clean (upper $.module)}}, error)
	Update(ctx context.Context, data *domain.{{clean (upper $.module)}}, ID string) (*domain.{{clean (upper $.module)}}, error)
	RemoveByID(ctx context.Context, ID string) error
	RestoreByID(ctx context.Context, ID string) error
}
`

//ImplementUsecaseTemplate template implement from interface usecase
const ImplementUsecaseTemplate = `package usecase

import (
	"context"
	"encoding/json"
	"fmt"
	"{{$.GoModules}}/internal/modules/{{$.module}}/domain"
	"{{$.GoModules}}/internal/modules/{{$.module}}/repository"
	"{{$.GoModules}}/pkg/shared"
	"time"

	"{{$.LibraryAddress}}/codebase/interfaces"
	"{{$.LibraryAddress}}/golibshared"
	"{{$.LibraryAddress}}/logger"
	"{{$.LibraryAddress}}/sdk"
	"{{$.LibraryAddress}}/tracer"
	"github.com/spf13/cast"
	"go.uber.org/zap/zapcore"
)

//{{$.module}}UsecaseImpl structure
type {{$.module}}UsecaseImpl struct {
	repo      *repository.Repository
	sdk       sdk.SDK
	validator interfaces.Validator
	cache     interfaces.Store
}

// New{{clean (upper $.module)}}Usecase create new {{$.module}} usecase
func New{{clean (upper $.module)}}Usecase(repo *repository.Repository, sdk sdk.SDK, validator interfaces.Validator, cache interfaces.Store) {{clean (upper $.module)}}Usecase {
	return &{{$.module}}UsecaseImpl{repo: repo, sdk: sdk, validator: validator, cache: cache}
}

func (uc *{{$.module}}UsecaseImpl) FindAll(ctx context.Context, filter *domain.Filter) (list{{clean (upper $.module)}} []*domain.{{clean (upper $.module)}}, meta *golibshared.Meta, err error) {
	opName := "{{$.module}}_usecase.find_all"

	tracer := tracer.StartTrace(ctx, opName)
	defer tracer.Finish(nil)
	ctx = tracer.Context()

	//get data {{$.module}} from repository
	repoRes := <-uc.repo.{{clean (upper $.module)}}.FindAll(ctx, filter)
	if repoRes.Error != nil {
		logger.Log(zapcore.ErrorLevel, repoRes.Error.Error(), opName, "find_{{$.module}}")
		return nil, nil, repoRes.Error
	}

	// transform data to struct
	{{$.module}} := repoRes.Data.([]*domain.{{clean (upper $.module)}})

	// count {{$.module}}
	countRes := <-uc.repo.{{clean (upper $.module)}}.Count(ctx, filter)
	if countRes.Error != nil {
		logger.Log(zapcore.ErrorLevel, countRes.Error.Error(), opName, "count_{{$.module}}")
		return nil, nil, countRes.Error
	}

	// transform data to struct
	total := countRes.Data.(int64)

	// set meta
	meta = golibshared.NewMeta(cast.ToInt64(filter.Page), cast.ToInt64(filter.Limit), total)

	return {{$.module}}, meta, nil
}

func (uc *{{$.module}}UsecaseImpl) FindByID(ctx context.Context, ID string) (*domain.{{clean (upper $.module)}}, error) {
	opName := "{{$.module}}_usecase.find_by_id"
	tracer := tracer.StartTrace(ctx, opName)
	defer tracer.Finish()

	var (
		err error
	)

	//check ID from cache redis. if found return!
	if cacheData, err := uc.cache.Get(ctx, ID); err == nil {
		var {{$.module}} domain.{{clean (upper $.module)}}
		json.Unmarshal([]byte(cacheData), &{{$.module}})
		return &{{$.module}}, nil
	}

	// get {{$.module}}
	repoRes := <-uc.repo.{{clean (upper $.module)}}.FindByID(ctx, ID)
	if repoRes.Error != nil {
		err = fmt.Errorf(shared.ErrorDataNotFound, "{{$.module}}")
		logger.Log(zapcore.ErrorLevel, err.Error(), opName, "find_{{$.module}}")
		return nil, err
	}

	// transform data to struct
	{{$.module}} := repoRes.Data.(*domain.{{clean (upper $.module)}})

	go func() {
		//set data if the redis not
		b, _ := json.Marshal({{$.module}})
		uc.cache.Set(ctx, {{$.module}}.ID.Hex(), b, 100*time.Minute)
	}()

	return {{$.module}}, nil
}

func (uc *{{$.module}}UsecaseImpl) Create(ctx context.Context, data *domain.{{clean (upper $.module)}}) (*domain.{{clean (upper $.module)}}, error) {
	opName := "{{$.module}}_usecase.create"
	tracer := tracer.StartTrace(ctx, opName)
	defer tracer.Finish(nil)
	ctx = tracer.Context()

	var (
		err error
	)

	//set is active true for new {{$.module}}
	data.IsActive = true

	// get {{$.module}} by name
	repoResCheckName := <-uc.repo.{{clean (upper $.module)}}.Find(ctx, domain.{{clean (upper $.module)}}{Name: data.Name})
	if repoResCheckName.Error == nil {
		err = fmt.Errorf(shared.ErrorDataAlreadyExist, "name {{$.module}}")
		logger.Log(zapcore.ErrorLevel, err.Error(), opName, "find_{{$.module}}")
		return nil, err
	}

	//save data to db
	repoRes := <-uc.repo.{{clean (upper $.module)}}.Insert(ctx, data)
	if repoRes.Error != nil {
		logger.Log(zapcore.ErrorLevel, repoRes.Error.Error(), opName, "insert_{{$.module}}")
		return nil, repoRes.Error
	}

	// transform data to struct
	{{$.module}} := repoRes.Data.(*domain.{{clean (upper $.module)}})

	return {{$.module}}, nil
}

func (uc *{{$.module}}UsecaseImpl) Update(ctx context.Context, data *domain.{{clean (upper $.module)}}, ID string) (*domain.{{clean (upper $.module)}}, error) {
	opName := "{{$.module}}_usecase.update"
	tracer := tracer.StartTrace(ctx, opName)
	defer tracer.Finish(nil)
	ctx = tracer.Context()

	var (
		err error
	)

	// get {{$.module}} by id
	repoResCheckID := <-uc.repo.{{clean (upper $.module)}}.FindByID(ctx, ID)
	if repoResCheckID.Error != nil {
		err = fmt.Errorf(shared.ErrorDataNotFound, "{{$.module}}")
		logger.Log(zapcore.ErrorLevel, err.Error(), opName, "find_{{$.module}}")
		return nil, err
	}

	{{$.module}} := repoResCheckID.Data.(*domain.{{clean (upper $.module)}})
	{{$.module}}.Name = data.Name

	//update data to db
	repoRes := <-uc.repo.{{clean (upper $.module)}}.Save(ctx, {{$.module}})
	if repoRes.Error != nil {
		logger.Log(zapcore.ErrorLevel, repoRes.Error.Error(), opName, "update_{{$.module}}")
		return nil, repoRes.Error
	}

	// transform data to struct
	{{$.module}}Update := repoRes.Data.(*domain.{{clean (upper $.module)}})

	go func() {
		//remove data in redis with key
		uc.cache.Delete(ctx, ID)
	}()

	return {{$.module}}Update, nil
}

func (uc *{{$.module}}UsecaseImpl) RemoveByID(ctx context.Context, ID string) error {
	opName := "{{$.module}}_usecase.remove_by_id"

	var (
		err error
	)

	// get {{$.module}}
	repoResCheckID := <-uc.repo.{{clean (upper $.module)}}.FindByID(ctx, ID)
	if repoResCheckID.Error != nil {
		err = fmt.Errorf(shared.ErrorDataNotFound, "{{$.module}}")
		logger.Log(zapcore.ErrorLevel, err.Error(), opName, "find_{{$.module}}")
		return err
	}

	// transform data to struct
	{{$.module}} := repoResCheckID.Data.(*domain.{{clean (upper $.module)}})
	if !{{$.module}}.IsActive {
		err = fmt.Errorf(shared.ErrorDataNotActived, "{{$.module}}")
		logger.Log(zapcore.ErrorLevel, err.Error(), opName, "find_{{$.module}}")
		return err
	}

	{{$.module}}.IsActive = false

	//update data to db
	repoRes := <-uc.repo.{{clean (upper $.module)}}.Save(ctx, {{$.module}})
	if repoRes.Error != nil {
		logger.Log(zapcore.ErrorLevel, repoRes.Error.Error(), opName, "update_{{$.module}}")
		return repoRes.Error
	}

	go func() {
		//remove data in redis with key
		uc.cache.Delete(ctx, ID)
	}()

	return nil
}

func (uc *{{$.module}}UsecaseImpl) RestoreByID(ctx context.Context, ID string) error {
	opName := "{{$.module}}_usecase.restore_by_id"
	var (
		err error
	)

	// get {{$.module}}
	repoResCheckID := <-uc.repo.{{clean (upper $.module)}}.FindByID(ctx, ID)
	if repoResCheckID.Error != nil {
		err = fmt.Errorf(shared.ErrorDataNotFound, "{{$.module}}")
		logger.Log(zapcore.ErrorLevel, err.Error(), opName, "find_{{$.module}}")
		return err
	}

	// transform data to struct
	{{$.module}} := repoResCheckID.Data.(*domain.{{clean (upper $.module)}})
	if {{$.module}}.IsActive {
		err = fmt.Errorf(shared.ErrorDataIsActived, "{{$.module}}")
		logger.Log(zapcore.ErrorLevel, err.Error(), opName, "find_{{$.module}}")
		return err
	}

	{{$.module}}.IsActive = true

	//update data to db
	repoRes := <-uc.repo.{{clean (upper $.module)}}.Save(ctx, {{$.module}})
	if repoRes.Error != nil {
		logger.Log(zapcore.ErrorLevel, repoRes.Error.Error(), opName, "update_{{$.module}}")
		return repoRes.Error
	}

	go func() {
		//remove data in redis with key
		uc.cache.Delete(ctx, ID)
	}()

	return nil
}
`

//TestUsecaseTemplate template test implement usecase
const TestUsecaseTemplate = `package usecase

import (
	"context"
	"fmt"
	"{{$.GoModules}}/internal/modules/{{$.module}}/domain"
	"{{$.GoModules}}/internal/modules/{{$.module}}/repository"
	{{$.module}}RepoMock "{{$.GoModules}}/internal/modules/{{$.module}}/repository/interfaces/mock"
	pkgMock "{{$.GoModules}}/pkg/mock/mocks"
	"{{$.GoModules}}/pkg/shared"
	"testing"
	"time"

	"github.com/brianvoe/gofakeit"

	authMock "{{$.LibraryAddress}}/sdk/auth-service/mocks"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"{{$.LibraryAddress}}/golibshared"
	"{{$.LibraryAddress}}/sdk"
	"go.mongodb.org/mongo-driver/mongo"
)

var (
	ctx              context.Context
	{{$.module}}UsecaseMocks {{clean (upper $.module)}}Usecase
	{{$.module}}RepoMocks    *{{$.module}}RepoMock.{{clean (upper $.module)}}Repository
	validatorMocks   *pkgMock.Validator
	storageMocks     *pkgMock.Storage
	authMocks        *authMock.ServiceAuth
)

func {{$.module}}UsecaseMock() {
	//set context
	ctx = context.Background()

	// set repo
	mongodb := &mongo.Database{}
	repo := repository.NewRepository(mongodb, mongodb)
	{{$.module}}RepoMocks = &{{$.module}}RepoMock.{{clean (upper $.module)}}Repository{}
	repo.{{clean (upper $.module)}} = {{$.module}}RepoMocks

	// set service
	authMocks = &authMock.ServiceAuth{}
	sdk := sdk.NewSDK(
		sdk.SetAuthService(authMocks),
	)

	//set validator mock
	validatorMocks = &pkgMock.Validator{}

	storageMocks = &pkgMock.Storage{}

	// set usecase
	{{$.module}}UsecaseMocks = New{{clean (upper $.module)}}Usecase(repo, sdk, validatorMocks, storageMocks)

}

func TestNew{{clean (upper $.module)}}Usecase(t *testing.T) {
	testName := shared.SetTestcaseName(1, "new {{$.module}} usecase")

	t.Run(testName, func(t *testing.T) {
		{{$.module}}UsecaseMock()

		// set usecase
		usecase := {{$.module}}UsecaseMocks

		assert.NotNil(t, usecase)
	})

}

func Test_{{$.module}}UsecaseImpl_FindAll(t *testing.T) {
	testCase := map[string]struct {
		wantError bool
		findAll   *golibshared.Result
		count     *golibshared.Result
	}{
		shared.SetTestcaseName(1, "positive find all {{$.module}}"): {
			wantError: false,
			findAll: &golibshared.Result{Data: []*domain.{{clean (upper $.module)}}{
				&domain.{{clean (upper $.module)}}{},
			}},
			count: &golibshared.Result{Data: int64(1)},
		},
		shared.SetTestcaseName(2, "negative find all count {{$.module}}"): {
			wantError: true,
			findAll: &golibshared.Result{Data: []*domain.{{clean (upper $.module)}}{
				&domain.{{clean (upper $.module)}}{},
			}},
			count: &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
		},
		shared.SetTestcaseName(3, "negative find all find {{$.module}}"): {
			wantError: true,
			findAll:   &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
		},
	}
	for name, test := range testCase {
		t.Run(name, func(t *testing.T) {
			{{$.module}}UsecaseMock()
			if test.findAll != nil {
				result := shared.SetMockerySharedResult(*test.findAll)
				{{$.module}}RepoMocks.On("FindAll", mock.Anything, mock.Anything).Return(result).Once()
			}

			if test.count != nil {
				result := shared.SetMockerySharedResult(*test.count)
				{{$.module}}RepoMocks.On("Count", mock.Anything, mock.Anything).Return(result).Once()
			}

			// set usecase
			usecase := {{$.module}}UsecaseMocks

			// run the usecase
			_, _, err := usecase.FindAll(ctx, &domain.Filter{})
			if test.wantError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}

			{{$.module}}RepoMocks.AssertExpectations(t)
		})
	}
}

func Test_{{$.module}}UsecaseImpl_FindByID(t *testing.T) {
	type redis struct {
		{{$.module}}  *domain.{{clean (upper $.module)}}
		Error error
	}
	testCase := map[string]struct {
		wantError     bool
		ID            string
		redis, redis2 *redis
		find          *golibshared.Result
	}{
		shared.SetTestcaseName(1, "positive find by id get from redis"): {
			wantError: false,
			ID:        "5f62fcee09cd352630be5237",
			redis:     &redis{ {{$.module}}: &domain.{{clean (upper $.module)}}{}},
		},
		shared.SetTestcaseName(2, "positive find by id get from database and save redis"): {
			wantError: false,
			ID:        "5f62fcee09cd352630be5237",
			redis:     &redis{Error: fmt.Errorf(golibshared.ErrorGeneral)},
			find:      &golibshared.Result{Data: &domain.{{clean (upper $.module)}}{}},
			redis2:    &redis{ {{$.module}}: &domain.{{clean (upper $.module)}}{}},
		},

		shared.SetTestcaseName(3, "negative find by id"): {
			wantError: true,
			ID:        "12345",
			redis:     &redis{Error: fmt.Errorf(golibshared.ErrorGeneral)},
			find:      &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
		},
		shared.SetTestcaseName(3, "negative find by id"): {
			wantError: true,
			ID:        "",
			redis:     &redis{Error: fmt.Errorf(golibshared.ErrorGeneral)},
			find:      &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
		},
	}
	for name, test := range testCase {
		t.Run(name, func(t *testing.T) {
			{{$.module}}UsecaseMock()

			if test.redis != nil {
				var data string = mock.Anything
				var err error = test.redis.Error
				storageMocks.On("Get", mock.Anything, mock.Anything).Return(data, err).Once()
			}

			if test.find != nil {
				result := shared.SetMockerySharedResult(*test.find)
				{{$.module}}RepoMocks.On("FindByID", mock.Anything, mock.Anything).Return(result).Once()
			}

			if test.redis2 != nil {
				var data string = mock.Anything
				var err error = test.redis2.Error
				storageMocks.On("Set", mock.Anything, mock.Anything, mock.Anything, 100*time.Minute).Return(data, err).Once()
			}

			// set usecase
			usecase := {{$.module}}UsecaseMocks

			// run the usecase
			_, err := usecase.FindByID(ctx, test.ID)
			if test.wantError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}

			{{$.module}}RepoMocks.AssertExpectations(t)
		})
	}

}

func Test_{{$.module}}UsecaseImpl_Create(t *testing.T) {
	testCase := map[string]struct {
		wantError   bool
		dataUsecase *domain.{{clean (upper $.module)}}
		find        *golibshared.Result
		insert      *golibshared.Result
	}{
		shared.SetTestcaseName(1, "negative name already taken"): {
			wantError: true,
			dataUsecase: &domain.{{clean (upper $.module)}}{
				Name: gofakeit.Name(),
			},
			find: &golibshared.Result{Data: &domain.{{clean (upper $.module)}}{}},
		},
		shared.SetTestcaseName(2, "positive name not already taken"): {
			wantError: false,
			dataUsecase: &domain.{{clean (upper $.module)}}{
				Name: gofakeit.Name(),
			},
			find:   &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
			insert: &golibshared.Result{Data: &domain.{{clean (upper $.module)}}{}},
		},
		shared.SetTestcaseName(3, "data {{$.module}} is nil"): {
			wantError:   true,
			dataUsecase: &domain.{{clean (upper $.module)}}{},
			find:        &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
			insert:      &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
		},
	}
	for name, test := range testCase {
		t.Run(name, func(t *testing.T) {
			{{$.module}}UsecaseMock()

			if test.find != nil {
				result := shared.SetMockerySharedResult(*test.find)
				{{$.module}}RepoMocks.On("Find", mock.Anything, mock.Anything).Return(result).Once()
			}

			if test.insert != nil {
				result := shared.SetMockerySharedResult(*test.insert)
				{{$.module}}RepoMocks.On("Insert", mock.Anything, mock.Anything).Return(result).Once()
			}

			// set usecase
			usecase := {{$.module}}UsecaseMocks

			// run the usecase
			_, err := usecase.Create(ctx, test.dataUsecase)
			if test.wantError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}

			{{$.module}}RepoMocks.AssertExpectations(t)
		})
	}

}

func Test_{{$.module}}UsecaseImpl_Update(t *testing.T) {
	type redis struct {
		{{$.module}}  *domain.{{clean (upper $.module)}}
		Error error
	}
	testCase := map[string]struct {
		wantError   bool
		dataUsecase *domain.{{clean (upper $.module)}}
		ID          string
		findByID    *golibshared.Result
		update      *golibshared.Result
		redis       *redis
	}{
		shared.SetTestcaseName(1, "negative ID is not found"): {
			wantError: true,
			dataUsecase: &domain.{{clean (upper $.module)}}{
				Name: gofakeit.Name(),
			},
			findByID: &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
		},
		shared.SetTestcaseName(2, "positive ID found"): {
			wantError: false,
			dataUsecase: &domain.{{clean (upper $.module)}}{
				Name: gofakeit.Name(),
			},
			ID:       "5f62fcee09cd352630be5237",
			findByID: &golibshared.Result{Data: &domain.{{clean (upper $.module)}}{}},
			update:   &golibshared.Result{Data: &domain.{{clean (upper $.module)}}{}},
			redis:    &redis{ {{$.module}}: &domain.{{clean (upper $.module)}}{}},
		},
		shared.SetTestcaseName(3, "data {{$.module}} is null"): {
			wantError:   true,
			dataUsecase: &domain.{{clean (upper $.module)}}{},
			ID:          "5f62fcee09cd352630be5237",
			findByID:    &golibshared.Result{Data: &domain.{{clean (upper $.module)}}{}},
			update:      &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
		},
	}
	for name, test := range testCase {
		t.Run(name, func(t *testing.T) {
			{{$.module}}UsecaseMock()

			if test.findByID != nil {
				result := shared.SetMockerySharedResult(*test.findByID)
				{{$.module}}RepoMocks.On("FindByID", mock.Anything, mock.Anything).Return(result).Once()
			}

			if test.update != nil {
				result := shared.SetMockerySharedResult(*test.update)
				{{$.module}}RepoMocks.On("Save", mock.Anything, mock.Anything).Return(result).Once()
			}

			if test.redis != nil {
				var data string = mock.Anything
				var err error = test.redis.Error
				storageMocks.On("Delete", mock.Anything, mock.Anything).Return(data, err).Once()
			}

			// set usecase
			usecase := {{$.module}}UsecaseMocks

			// run the usecase
			_, err := usecase.Update(ctx, test.dataUsecase, test.ID)
			if test.wantError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}

			{{$.module}}RepoMocks.AssertExpectations(t)
		})
	}
}

func Test_{{$.module}}UsecaseImpl_RemoveByID(t *testing.T) {
	type redis struct {
		{{$.module}}  *domain.{{clean (upper $.module)}}
		Error error
	}
	testCase := map[string]struct {
		wantError bool
		ID        string
		findByID  *golibshared.Result
		remove    *golibshared.Result
		redis     *redis
	}{
		shared.SetTestcaseName(0, "Positive case, ID ditemukan dan data tidak dalam keadaan non active"): {
			wantError: false,
			ID:        "5f62fcee09cd352630be5237",
			findByID: &golibshared.Result{Data: &domain.{{clean (upper $.module)}}{
				Name:     gofakeit.Name(),
				IsActive: true,
			}},
			remove: &golibshared.Result{Data: &domain.{{clean (upper $.module)}}{}},
			redis:  &redis{ {{$.module}}: &domain.{{clean (upper $.module)}}{}},
		},
		shared.SetTestcaseName(1, "Data sudah dalam keadaan non active"): {
			wantError: true,
			ID:        "5f62fcee09cd352630be5237",
			findByID: &golibshared.Result{Data: &domain.{{clean (upper $.module)}}{
				Name:     gofakeit.Name(),
				IsActive: false,
			}},
		},
		shared.SetTestcaseName(2, "ID tidak ditemukan"): {
			wantError: true,
			ID:        "5f62fcee09cd352630be5237",
			findByID:  &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
		},
		shared.SetTestcaseName(3, "Invalid format ID"): {
			wantError: true,
			ID:        "01w313!!!!!",
			findByID:  &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
		},
		shared.SetTestcaseName(4, "Error Save data"): {
			wantError: true,
			ID:        "5f62fcee09cd352630be5237",
			findByID: &golibshared.Result{Data: &domain.{{clean (upper $.module)}}{
				Name:     gofakeit.Name(),
				IsActive: true,
			}},
			remove: &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
		},
	}
	for name, test := range testCase {
		t.Run(name, func(t *testing.T) {
			{{$.module}}UsecaseMock()

			if test.findByID != nil {
				result := shared.SetMockerySharedResult(*test.findByID)
				{{$.module}}RepoMocks.On("FindByID", mock.Anything, mock.Anything).Return(result).Once()
			}

			if test.remove != nil {
				result := shared.SetMockerySharedResult(*test.remove)
				{{$.module}}RepoMocks.On("Save", mock.Anything, mock.Anything).Return(result).Once()
			}

			if test.redis != nil {
				var data string = mock.Anything
				var err error = test.redis.Error
				storageMocks.On("Delete", mock.Anything, mock.Anything).Return(data, err).Once()
			}

			// set usecase
			usecase := {{$.module}}UsecaseMocks

			// run the usecase
			err := usecase.RemoveByID(ctx, test.ID)
			if test.wantError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}

			{{$.module}}RepoMocks.AssertExpectations(t)
		})
	}
}

func Test_{{$.module}}UsecaseImpl_RestoreByID(t *testing.T) {
	type redis struct {
		{{$.module}}  *domain.{{clean (upper $.module)}}
		Error error
	}
	testCase := map[string]struct {
		wantError bool
		ID        string
		findByID  *golibshared.Result
		restore   *golibshared.Result
		redis     *redis
	}{
		shared.SetTestcaseName(0, "Positive case, ID ditemukan dan data tidak dalam keadaan non active"): {
			wantError: false,
			ID:        "5f62fcee09cd352630be5237",
			findByID: &golibshared.Result{Data: &domain.{{clean (upper $.module)}}{
				Name:     gofakeit.Name(),
				IsActive: false,
			}},
			restore: &golibshared.Result{Data: &domain.{{clean (upper $.module)}}{}},
			redis:   &redis{ {{$.module}}: &domain.{{clean (upper $.module)}}{}},
		},
		shared.SetTestcaseName(1, "Data sudah dalam keadaan non active"): {
			wantError: true,
			ID:        "5f62fcee09cd352630be5237",
			findByID: &golibshared.Result{Data: &domain.{{clean (upper $.module)}}{
				Name:     gofakeit.Name(),
				IsActive: true,
			}},
		},
		shared.SetTestcaseName(2, "ID tidak ditemukan"): {
			wantError: true,
			ID:        "5f62fcee09cd352630be5237",
			findByID:  &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
		},
		shared.SetTestcaseName(3, "Invalid format ID"): {
			wantError: true,
			ID:        "01w313!!!!!",
			findByID:  &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
		},
		shared.SetTestcaseName(4, "Error Save data"): {
			wantError: true,
			ID:        "5f62fcee09cd352630be5237",
			findByID: &golibshared.Result{Data: &domain.{{clean (upper $.module)}}{
				Name:     gofakeit.Name(),
				IsActive: false,
			}},
			restore: &golibshared.Result{Error: fmt.Errorf(golibshared.ErrorGeneral)},
		},
	}
	for name, test := range testCase {
		t.Run(name, func(t *testing.T) {
			{{$.module}}UsecaseMock()

			if test.findByID != nil {
				result := shared.SetMockerySharedResult(*test.findByID)
				{{$.module}}RepoMocks.On("FindByID", mock.Anything, mock.Anything).Return(result).Once()
			}

			if test.restore != nil {
				result := shared.SetMockerySharedResult(*test.restore)
				{{$.module}}RepoMocks.On("Save", mock.Anything, mock.Anything).Return(result).Once()
			}

			if test.redis != nil {
				var data string = mock.Anything
				var err error = test.redis.Error
				storageMocks.On("Delete", mock.Anything, mock.Anything).Return(data, err).Once()
			}

			// set usecase
			usecase := {{$.module}}UsecaseMocks

			// run the usecase
			err := usecase.RestoreByID(ctx, test.ID)
			if test.wantError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}

			{{$.module}}RepoMocks.AssertExpectations(t)
		})
	}
}
`
